{


	"compress_array": {
		"prefix": "compress_array",
		"body": [
			"import typing ",
			"",
			"",
			"",
			"class CompressArray():",
			"  def retrieve(",
			"    self,",
			"    i: int,",
			"  ) -> int:",
			"    return self.__v[i]",
			"  ",
			"",
			"  def __call__(",
			"    self,",
			"    a: typing.Iterable[int],",
			"  ) -> typing.List[int]:",
			"    a = sorted(",
			"      enumerate(a),",
			"      key=lambda x: x[1],",
			"    )",
			"    n = len(a)",
			"    b = [None] * n",
			"    v = [None] * n",
			"    i, mn = -1, -float('inf')",
			"    for j, x in a:",
			"      if x > mn: ",
			"        i += 1",
			"        v[i] = x",
			"        mn = x",
			"      b[j] = i",
			"    self.__v = v",
			"    return b"
		],
		"description": "compress_array"
	},




	"fenwick_tree": {
		"prefix": "fenwick_tree",
		"body": [
			"import typing",
			"",
			"",
			"class FenwickTree():",
			"  def __init__(",
			"    self,",
			"    n: int,",
			"  ) -> typing.NoReturn:",
			"    self.__buf = [0] * (n + 1)",
			"  ",
			"",
			"  def add(",
			"    self,",
			"    i: int,",
			"    x: int,",
			"  ) -> typing.NoReturn:",
			"    b = self.__buf",
			"    n = len(b)",
			"    while i < n:",
			"      b[i] += x",
			"      i += i & -i",
			"  ",
			"",
			"  def sum(",
			"    self,",
			"    i: int,",
			"  ) -> int:",
			"    b = self.__buf",
			"    s = 0 ",
			"    while i > 0:",
			"      s += b[i]",
			"      i -= i & -i",
			"    return s"
		],
		"description": "fenwick_tree"
	},



	"graph": {
		"prefix": "graph",
		"body": [
			"import typing",
			"from typing import (",
			"  List,",
			"  Optional,",
			")",
			"import dataclasses",
			"",
			"",
			"",
			"@dataclasses.dataclass",
			"class Node:",
			"  id_: Optional[int] = None",
			"",
			"",
			"",
			"@dataclasses.dataclass ",
			"class Edge:",
			"  id_: Optional[int] = None",
			"  from_ : int = ... ",
			"  to: int = ... ",
			"  weight: int = 1",
			"  capacity: int = 0",
			"",
			"",
			"",
			"@dataclasses.dataclass",
			"class Graph:",
			"  nodes: List[Node]",
			"  edges: List[List[Edge]]",
			"",
			"",
			"  def __init__(",
			"    self,",
			"    n: int,",
			"  ) -> typing.NoReturn:",
			"    nodes = [",
			"      Node(i)",
			"      for i in range(n)",
			"    ]",
			"    edges = [",
			"      [] for _ in range(n)",
			"    ]",
			"    self.nodes = nodes ",
			"    self.edges = edges",
			"  ",
			"",
			"  def add_edge(",
			"    self,",
			"    e: Edge,",
			"  ) -> typing.NoReturn:",
			"    i = e.from_ ",
			"    self.edges[i].append(e)",
			"  ",
			"",
			"  def add_edges(",
			"    self,",
			"    edges: typing.List[Edge],",
			"  ) -> typing.NoReturn:",
			"    for e in edges:",
			"      self.add_edge(e)",
			"  ",
			"",
			"  @property ",
			"  def size(",
			"    self,",
			"  ) -> int:",
			"    return len(self.nodes)",
			"",
			""
		],
		"description": "graph"
	},


	


	"inversion count": {
		"prefix": "inversion_count",
		"body": [
			"import typing",
			"",
			"",
			"class InversionCount():",
			"  def __call__(",
			"    self,",
			"    a: typing.List[int],",
			"  ) -> int:",
			"    self.__a = a",
			"    self.__compress()",
			"    self.__calc()",
			"    return self.__cnt",
			"",
			"",
			"  def __calc(",
			"    self,",
			"  ) -> typing.NoReturn:",
			"    a = self.__a",
			"    n = len(a)",
			"    ft = FenwickTree(n)",
			"    c = 0",
			"    for i in range(n):",
			"      x = a[i]",
			"      c += i - ft.sum(x)",
			"      ft.add(x + 1, 1)",
			"    self.__cnt = c",
			"",
			"",
			"  def __compress(",
			"    self,",
			"  ) -> typing.NoReturn:",
			"    a = self.__a",
			"    fn = CompressArray()",
			"    self.__a = fn(a)  "
		],
		"description": "inversion count"
	},




	"Problem": {
		"prefix": "problem",
		"body": [
			"import typing",
			"",
			"",
			"class Problem(",
			"  Solver,",
			"):",
			"  def __init__(",
			"    self,",
			"  ) -> typing.NoReturn:",
			"    self.__read = ReadStdin()",
			"",
			"",
			"  def _prepare(",
			"    self,",
			"  ) -> typing.NoReturn:",
			"    ... ",
			"",
			"",
			"  def _solve(",
			"    self,",
			"  ) -> typing.NoReturn:",
			"    ...",
			"",
			"",
			"def main():",
			"  p = Problem()",
			"  t = 1",
			"  # t = ReadStdin().int()",
			"  for _ in range(t): p()",
			"",
			"",
			"if __name__ == '__main__':",
			"  main()"
		],
		"description": "Problem"
	},



	"ReadStdin": {
		"prefix": "read_stdin",
		"body": [
			"import typing",
			"",
			"",
			"",
			"class ReadStdin:",
			"  def __call__(",
			"    self,",
			"  ) -> bytes:",
			"    return next(self.__chunks)",
			"    ",
			"",
			"  def __init__(",
			"    self,",
			"  ) -> typing.NoReturn:",
			"    import sys",
			"    self.__buf = (",
			"      sys.stdin.buffer",
			"    )",
			"    self.__chunks = (",
			"      self.__read_chunks()",
			"    )",
			"",
			"",
			"  def int(",
			"    self,",
			"  ) -> int:",
			"    return int(self())",
			"",
			"",
			"  def __read_chunks(",
			"    self,",
			"  ) -> typing.Iterator[bytes]:",
			"    while 1:",
			"      l = self.__buf.readline()",
			"      for chunk in l.split():",
			"        yield chunk",
			"  ",
			"",
			"  def str(",
			"    self,",
			"  ) -> str:",
			"    b = self()",
			"    return b.decode()"
		],
		"description": "ReadStdin"
	},



	"Solver": {
		"prefix": "solver",
		"body": [
			"from abc import (",
			"  ABC,",
			"  abstractmethod,",
			")",
			"import typing",
			"",
			"",
			"",
			"class Solver(",
			"  ABC,",
			"):",
			"  def __call__(",
			"    self,",
			"  ) -> typing.NoReturn:",
			"    self._prepare()",
			"    self._solve()",
			"",
			"  ",
			"  def __init__(",
			"    self,",
			"  ) -> typing.NoReturn:",
			"    ...",
			"",
			"",
			"  @abstractmethod",
			"  def _prepare(",
			"    self,",
			"  ) -> typing.NoReturn:",
			"    ...",
			"",
			"  ",
			"  @abstractmethod",
			"  def _solve(",
			"    self,",
			"  ) -> typing.NoReturn:",
			"    ..."
		],
		"description": "Solver"
	},



}