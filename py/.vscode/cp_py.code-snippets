{



	"Problem": {
		"prefix": "problem",
		"body": [
			"import typing",
			"",
			"",
			"class Problem(",
			"  Solver,",
			"):",
			"  def __init__(",
			"    self,",
			"  ) -> typing.NoReturn:",
			"    self.__read = ReadStdin()",
			"",
			"",
			"  def _prepare(",
			"    self,",
			"  ) -> typing.NoReturn:",
			"    ... ",
			"",
			"",
			"  def _solve(",
			"    self,",
			"  ) -> typing.NoReturn:",
			"    ...",
			"",
			"",
			"def main():",
			"  p = Problem()",
			"  t = 1",
			"  # t = ReadStdin().int()",
			"  for _ in range(t): p()",
			"",
			"",
			"if __name__ == '__main__':",
			"  main()"
		],
		"description": "Problem"
	},



	"ReadStdin": {
		"prefix": "read_stdin",
		"body": [
			"import typing",
			"",
			"",
			"",
			"class ReadStdin:",
			"  def __call__(",
			"    self,",
			"  ) -> bytes:",
			"    return next(self.__chunks)",
			"    ",
			"",
			"  def __init__(",
			"    self,",
			"  ) -> typing.NoReturn:",
			"    import sys",
			"    self.__buf = (",
			"      sys.stdin.buffer",
			"    )",
			"    self.__chunks = (",
			"      self.__read_chunks()",
			"    )",
			"",
			"",
			"  def int(",
			"    self,",
			"  ) -> int:",
			"    return int(self())",
			"",
			"",
			"  def __read_chunks(",
			"    self,",
			"  ) -> typing.Iterator[bytes]:",
			"    while 1:",
			"      l = self.__buf.readline()",
			"      for chunk in l.split():",
			"        yield chunk",
			"  ",
			"",
			"  def str(",
			"    self,",
			"  ) -> str:",
			"    b = self()",
			"    return b.decode()"
		],
		"description": "ReadStdin"
	},



	"Solver": {
		"prefix": "solver",
		"body": [
			"from abc import (",
			"  ABC,",
			"  abstractmethod,",
			")",
			"import typing",
			"",
			"",
			"",
			"class Solver(",
			"  ABC,",
			"):",
			"  def __call__(",
			"    self,",
			"  ) -> typing.NoReturn:",
			"    self._prepare()",
			"    self._solve()",
			"",
			"  ",
			"  def __init__(",
			"    self,",
			"  ) -> typing.NoReturn:",
			"    ...",
			"",
			"",
			"  @abstractmethod",
			"  def _prepare(",
			"    self,",
			"  ) -> typing.NoReturn:",
			"    ...",
			"",
			"  ",
			"  @abstractmethod",
			"  def _solve(",
			"    self,",
			"  ) -> typing.NoReturn:",
			"    ..."
		],
		"description": "Solver"
	},



}